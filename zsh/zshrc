# Load dotfiles.env
[ -f "$HOME/.dotfiles.env" ] && source "$HOME/.dotfiles.env"

# Put private environment variables in ~/.dotfiles.local. It means they'll stay out
# of main dotfiles repository (which may be public, like this one), but
# you'll have access to them in your scripts.
if [[ -a ~/.dotfiles.local ]]
then
  source ~/.dotfiles.local
fi

######## HISTORY SETUP ######################

# tell zsh where to store command history
HISTFILE=$HOME/.zhistory

# store last ten thousand history commands
SAVEHIST=10000

# how many histories to keep in memory. For more it will have to read from the disk
HISTSIZE=999

# Share command history across multiple running zsh sessions
setopt share_history

# Drop duplicates before dropping history while trying to not exceed HISTIZE value
setopt hist_expire_dups_first

# Don’t record a command if it’s exactly the same as the previous command in history.
# If you run ls then ls again immediately, the second one won’t be added.
# It only ignores consecutive duplicates.
setopt hist_ignore_dups

# When executing history commands like !!, !$, !grep the command will be first expanded
# you will get to see the command before it's executed to avoid cases like I didn't want
# to run that command
setopt hist_verify

# Remap what Up and Down arrows do in Zsh.
# ^[ means the ESC character. So ^[[A is literally: ESC, [, A.
# ^[[A = Up arrow
# ^[[B = Down arrow
bindkey '^[[A' history-search-backward
bindkey '^[[B' history-search-forward

# zsh-autosuggestions (brew)
if command -v brew >/dev/null 2>&1; then
  ZSH_AUTOSUGGESTIONS="${HOMEBREW_PREFIX:-$(brew --prefix)}/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
  [[ -f "$ZSH_AUTOSUGGESTIONS" ]] && source "$ZSH_AUTOSUGGESTIONS"
fi

# zsh-syntax-highlighting (brew)
if command -v brew >/dev/null 2>&1; then
  ZSH_SYNTAX_HIGHLIGHTING="${HOMEBREW_PREFIX:-$(brew --prefix)}/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
  [[ -f "$ZSH_SYNTAX_HIGHLIGHTING" ]] && source "$ZSH_SYNTAX_HIGHLIGHTING"
fi

source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

eval "$(atuin init zsh)"
eval "$(zoxide init zsh)"
source "$DOTFILESD/zsh/prompt.zshrc"

##### ALIASES #####
alias reload!='. ~/.zshrc'

# GIT aliases
alias gps='git push origin HEAD'
alias gs='git status'
alias gap='git add -p'
alias gc='git commit'
alias gco='git checkout'
alias glg='git lg'
alias glg2='git lg2'
alias gwip='git add . && git commit -m "wip"'
alias aic="aicommits"

# git root
alias gr='[ ! -z `git rev-parse --show-cdup` ] && cd `git rev-parse --show-cdup || pwd`'

# Update local branch from the remote, and also clean up remote branches.
# It means if a branch was deleted on the remote (say origin/feature-x), then
# local reference origin/feature-x gets removed too.
alias gpl='git pull --prune'

# prefer eza
alias ls="eza --icons=always"
alias ll='eza --classify=auto --color -l --icons=always'
alias la='eza --classify=auto --color -a -l --icons=always'

# Easy way to copy publick key to the clipboard.
alias pubkey="more ~/.ssh/id_rsa.pub | pbcopy | echo '=> Public key copied to pasteboard.'"

alias cld="claude"
alias cldd="claude --dangerously-skip-permissions"

# Easier navigation
alias cd..="cd .."
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."

# open VSCode from the present directory
alias c="code ."

# mv, rm, cp
alias mv='mv -v'
alias rm='rm -i -v'
alias cp='cp -v'
alias h='history'

alias hosts='sudo $EDITOR /etc/hosts'   # yes I occasionally 127.0.0.1 x.com

alias dotfiles="code $DOTFILESD" # open dotfiles

# take me to the dotfiles directory
alias dotfilesd="cd $DOTFILESD" # open dotfiles

# neeto repos
alias neetozone="cd ~/code/neetozone"
alias authw="cd ~/code/neetozone/neeto-auth-web"
alias formw="cd ~/code/neetozone/neeto-form-web"
alias calw="cd ~/code/neetozone/neeto-cal-web"
alias chatw="cd ~/code/neetozone/neeto-chat-web"
alias deskw="cd ~/code/neetozone/neeto-desk-web"
alias kbw="cd ~/code/neetozone/neeto-kb-web"
alias quizw="cd ~/code/neetozone/neeto-quiz-web"
alias sitew="cd ~/code/neetozone/neeto-site-web"
alias runnerw="cd ~/code/neetozone/neeto-runner-web"
alias replayw="cd ~/code/neetozone/neeto-replay-web"
alias invoicew="cd ~/code/neetozone/neeto-invoice-web"
alias plannerw="cd ~/code/neetozone/neeto-planner-web"
alias coursew="cd ~/code/neetozone/neeto-course-web"
alias wireframew="cd ~/code/neetozone/neeto-wireframe-web"
alias engagew="cd ~/code/neetozone/neeto-engage-web"
alias crmw="cd ~/code/neetozone/neeto-crm-web"
alias deployw="cd ~/code/neetozone/neeto-deploy-web"
alias ciw="cd ~/code/neetozone/neeto-ci-web"
alias gitw="cd ~/code/neetozone/neeto-git-web"
alias recordw="cd ~/code/neetozone/neeto-record-web"
alias towerw="cd ~/code/neetozone/neeto-tower-web"
alias publishw="cd ~/code/neetozone/neeto-publish-web"
alias playdashw="cd ~/code/neetozone/neeto-playdash-web"
alias codew="cd ~/code/neetozone/neeto-code-web"
alias payw="cd ~/code/neetozone/neeto-pay-web"
alias bugwatchw="cd ~/code/neetozone/neeto-bugwatch-web"

# Away From Keyboard (AFK) - Start screen saver
alias afk="open /System/Library/CoreServices/ScreenSaverEngine.app"

# GRC colorizes logfiles and command output
# https://stackoverflow.com/questions/25183624/grc-bashrc-no-such-file-or-directory
if (( $+commands[grc] )) && (( $+commands[brew] ))
then
  source `brew --prefix`/etc/grc.bashrc
fi

# Add bin folder to PATH
export PATH="$DOTFILESD/bin:$PATH"

# if condition is checking if homebrew is installed or not
# `brew shellenv`` prints a bunch of shell commands like export PATH=..., export HOMEBREW_PREFIX=..., etc.
# that sets your environment so your shell can “find Homebrew” (and the stuff you install with it) in the right places.
# eval "$( ... )" executes those printed commands in the current shell.
if command -v brew >/dev/null; then
  eval "$(brew shellenv)"
fi

# load the compinit function when I first use it.
# -U avoids alias expansion; -z uses zsh-style autoloading.
autoload -Uz compinit

# compinit initializes zsh’s completion system (tab completion).
# It loads completion definitions so things like git <TAB> or brew <TAB> work nicely.
compinit

eval "$(rbenv init - zsh)"

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# nvm doesn’t auto-switch Node versions just because you “entered a folder”.
# By default, nvm only changes Node when you explicitly tell it to (like nvm use 22.13)
# or when your shell is configured to do “auto use”.
#
# nvm is a shell function, not a background daemon. It has no idea you cd’d into a
# repo unless your shell is configured to run nvm use when you change directories.
# So unless you’ve set up auto-switching, nvm will happily keep whatever
# Node version is currently selected in that terminal.
#
# enable an auto-switch hook in your shell (zsh).
autoload -U add-zsh-hook
load-nvmrc() {
  local nvmrc_path
  nvmrc_path="$(nvm_find_nvmrc)"

  if [[ -n "$nvmrc_path" ]]; then
    local nvmrc_node_version
    nvmrc_node_version="$(cat "$nvmrc_path")"

    local current_node_version
    current_node_version="$(node -v 2>/dev/null | sed 's/^v//')"

    if [[ "$current_node_version" != "$nvmrc_node_version" ]]; then
      nvm use --silent "$nvmrc_node_version" >/dev/null
    fi
  fi
}
add-zsh-hook chpwd load-nvmrc
load-nvmrc

export PATH="$HOME/.local/bin:$PATH"

# Add Visual Studio Code (code)
export PATH="$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin"

export PATH="/opt/homebrew/opt/postgresql@18/bin:$PATH"
