# Load dotfiles.env
[ -f "$HOME/.dotfiles.env" ] && source "$HOME/.dotfiles.env"

# Put private environment variables in ~/.dotfiles.local. It means they'll stay out
# of main dotfiles repository (which may be public, like this one), but
# you'll have access to them in your scripts.
if [[ -a ~/.dotfiles.local ]]
then
  source ~/.dotfiles.local
fi

# Get all the .zshrc files and source them
for f in $DOTFILESD/**/*.zshrc(.); do source "$f"; done

# Add bin folder to PATH
export PATH="$DOTFILESD/bin:$PATH"

# tree but only print directories
# by default the depth level is 1 but an argument can be passed
# treed 3 - to have three levels of depth
treed() {
  tree -AdL ${1:-1}
}

# Create a new directory and enter it
mk() {
  mkdir -p "$@" && cd "$@"
}

# cd into latest created directory
# this is needed because I keep forgetting to use mk
cdl() {
  cd "$(ls -dt */ | head -n 1)"
}

# List only duplicate lines
duplines() {
  sort $1 | uniq -d
}

# List only unique lines
uniqlines() {
  sort $1 | uniq -u
}


# if condition is checking if homebrew is installed or not
# `brew shellenv`` prints a bunch of shell commands like export PATH=..., export HOMEBREW_PREFIX=..., etc.
# eval "$( ... )" executes those printed commands in your current shell.
if command -v brew >/dev/null; then
  eval "$(brew shellenv)"
fi

# load the compinit function when I first use it.
# -U avoids alias expansion; -z uses zsh-style autoloading.
autoload -Uz compinit

# compinit initializes zsh’s completion system (tab completion).
# It loads completion definitions so things like git <TAB> or brew <TAB> work nicely.
compinit

# Show system information
sysinfo() {
  echo "CPU: $(sysctl -n machdep.cpu.brand_string)"
  echo "RAM: $(top -l 1 -s 0 | grep PhysMem | sed 's/^[[:space:]]*//')"
  echo
  system_profiler SPDisplaysDataType
}

# Away From Keyboard (AFK) - Start screen saver
alias afk="open /System/Library/CoreServices/ScreenSaverEngine.app"

# Copy pwd to clipboard
pwdd(){ local dir="$PWD"; print -rn -- "$dir" | pbcopy; echo "copied: $dir to clipboard."; }

# force kill
fkill() {
  local pids
  pids=$(ps -eo pid=,command= | fzf -m --prompt='kill -9> ' --header='TAB to multi-select' | awk '{print $1}')
  [[ -n "$pids" ]] || return 0
  echo "$pids" | xargs kill -9
}

eval "$(rbenv init - zsh)"

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion


# nvm doesn’t auto-switch Node versions just because you “entered a folder”.
# By default, nvm only changes Node when you explicitly tell it to (like nvm use 22.13)
# or when your shell is configured to do “auto use”.
#
# nvm is a shell function, not a background daemon. It has no idea you cd’d into a
# repo unless your shell is configured to run nvm use when you change directories.
# So unless you’ve set up auto-switching, nvm will happily keep whatever
# Node version is currently selected in that terminal.
#
# enable an auto-switch hook in your shell (zsh).
autoload -U add-zsh-hook
load-nvmrc() {
  local nvmrc_path
  nvmrc_path="$(nvm_find_nvmrc)"

  if [[ -n "$nvmrc_path" ]]; then
    local nvmrc_node_version
    nvmrc_node_version="$(cat "$nvmrc_path")"

    local current_node_version
    current_node_version="$(node -v 2>/dev/null | sed 's/^v//')"

    if [[ "$current_node_version" != "$nvmrc_node_version" ]]; then
      nvm use --silent "$nvmrc_node_version" >/dev/null
    fi
  fi
}
add-zsh-hook chpwd load-nvmrc
load-nvmrc